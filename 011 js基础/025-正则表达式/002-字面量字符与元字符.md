## 2.1. 字面量字符(Literal Characters)
最基础的正则表达式由一个字面量字符组成，例如`a`。它将匹配一个字符串中第一个`a`出现的位置。如果它匹配的是` Jack is a boy`，那么它将匹配到J后面的a。事实上即使a出现在字符串的中间也不影响这个正则，如果你想控制a是否出现在字符串的开头或者结尾，那么你需要使用[文字边界](word boundaries)。我们会在后面的章节展开讨论。

事实上这个正则同样可以匹配字符串中的第二个`a`，但是你必须通过函数调用通知正则引擎开始第二次匹配。

相类似的，表达式`\cat\`可以匹配`About cats and dogs`中的`cat`。这个表达式由三个字面量字符组成，对于正则引擎而言，它的意义是：查找一个`c`它的后面紧接着一个`a`，`a`的后面紧接着一个`t`。

> 注意：在默认情况下，正则引擎的大小写敏感的。除非你要素引擎忽略大小写。

## 2.2 元字符

为了处理更复杂的正则匹配，我们需要把一些字符作为特殊字符使用。一下列出正则表达式中的12个元字符：

- `\`
- `^`
- `&`
- `.`
- `|`
- `?`
- `*`
- `+`
- `(`
- `)`
- `[`
- `{`

通常来说，这些特殊字符在单独使用时会引发错误。

如果你想把以上的字符作为字面量字符来使用，你必须使用`\`进行转义。例如，如果你想匹配`1+1=2`，那么正确的表达式为`/1\+1=2/`，因为加号有特殊的含义。

> 注意：`/1+1=2/`也是一个正确的表达式，但是它不会匹配`1+1=2`，它会匹配到`123+111=234`的`111=2`。这是由于[加号这个特殊字符](https://www.regular-expressions.info/repeat.html)导致的。

如果你忘记对元字符进行转义，那么在有些情况下会导致正则表达式非法，例如`/+1/`。这时程序会抛出异常。

### 2.2.1 `{`的转义
在大多数正则引擎中，我们可以直接把`{`作为字面量字符使用，除了作为重复操作使用例如`a{1,3}`。所以在一般情况下我们不需要对`{`进行转义，当然转义也不会报错。在一些特殊的正则引擎中，我们可能需要对它进行转义，例如在[java](https://www.regular-expressions.info/java.html)中，`}`需要转义，在[Boost](https://www.regular-expressions.info/stdregex.html)和[std::regex](https://www.regular-expressions.info/ruby.html)中`{`、`}`都需要转义。

### 2.2.2 `]`的转义
`]`在字符类(character classes)以外使用时，它是一个字面量字符。在字符类中使用的时候，则有不同的规则。具体的规则我们会在[字符类](https://www.regular-expressions.info/charclass.html)专题的展开讨论。
> 当然也有例外，在`std::regex`和`Ruby`中`]`即使不在字符类中也需要转义。

### 2.2.3 其它字符
除了以上这些元字符以外，其它的字符都不需要使用反斜杠转义。这是因为转移符和字面量字符的组合将成为一个正则指令（regex token），它具有特殊的含义。例如`\d`可以匹配0~9中任意一个字符。

## 2.3. 特殊字符与编程语言
在正则表达式中`'`和`"`并不是特殊字符，如何你是一个程序员的话你一定对此十分意外。在你编程或是使用文本编辑器的高级搜索功能时，你需要对单引号和双引号进行转义。

当你在代码中使用正则表达式的时候，你应当注意有些字符在你所使用的编程语言中有特殊的含义。这是因为这些字符在进入正则引擎之前，先要经过编译器的处理。在c++代码中，表达式`1\+1=2 `需要写成`1\\+1=2`，c++编译器会在编译过程中去掉一个反斜杠，并把编译后的结果传递给正则引擎。再举一个例子，正则表达式`c:\\temp`可以匹配字符串`c:\temp`，但是在c++中你需要这么写`c:\\\\temp`。简单来说就是用四个反斜杠代替一个正则中的斜杠。

有关正则在编程语言中的使用，我们对在后面的[章节](https://www.regular-expressions.info/tools.html)中展开讨论。

[原文](https://www.regular-expressions.info/characters.html)